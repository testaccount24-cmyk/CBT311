FINDMOD  TITLE 'Find a module - search LPA, LNKLST, Nuc, etc'
* =================================================================== *
*
* Name: FINDMOD
*
* Author: David Alcock
*
* Purpose: Search for a module everywhere! To wit:
*          o JPAQ
*          o //ISPLLIB
*          o LPA
*          o Static or Dynamic LNKLSTs
*          o Nucleus
*          o SVCLIB
*
* Attributes: Non-reentrant, Non-Authorized
*
*  Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*              is provided for your enjoyment and neither David
*              Alcock or his employer provides any warranty for it's
*              use.  I'd like to hear how it works on your system.
*
*              This software is not in the public domain but is
*              available free of charge and with source code
*              provided.  It is copyright 2002+ by David Alcock
*              All rights reserved.
*
* =================================================================== *
         SPACE 2
&DAVER   SETC  '1.0'
*======================================================================
*
*             M o d i f i c a t i o n   H i s t o r y
*
* Person     Date       VRM Description
* ---------- ---------- --- -------------------------------------------
* DGAlcock   2002-09-26 1.0 Initial program started;
*
*======================================================================
         EJECT ,
*
** Map IBM DSECTs
*
         EJECT ,
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO          Communications Vector Table
         IHAPDS PDSBLDL=YES               PDS Directory entry
         IHAASCB ,
         IHAASSB ,
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         IEFTIOT1 ,                       Task I/O Table
         IEFJFCBN ,                       Job File Control Block
         IEFJESCT ,                       JES communication area
         IHAPSA ,                         Prefixed Save Area
         IKJTCB ,                         Task Control Block
         IHAECVT ,                        Extended CVT
         IEFZB4D0 ,                       SVC 99 - RB
         IEFZB4D2 ,                       SVC 99 - Text Equates
         IEFZB505 LOCEPAX=YES             EPA mapping for SWAREQ
         IEFQMIDS ,                       Equates for SWA requests
         IHALDA ,                         Local Data Area
         IHAGDA ,                         VSM Global Data Area
         CSVDLCB TITLE=NO                 Dynamic LNKLST
         CSVDLAA ,                        Dynamic LNKLST
         IHACDE  ,                        Contents Directory Entry
         IKJCPPL ,                        Command Processor Parm List
         IKJIOPL ,                        I/O Parm List
#IOPL    EQU   *-IOPL
*        IHALLT &DSECT=YES             LNKLST/LPALST tables
LLT      DSECT
LLTID    DS    C'LLT '                 BLOCK ACRONYM
LLTCOUNT DS    F                       NUMBER OF ENTRIES
LLTENTRY DS    0CL45                   DSNAME ENTRY
LLTDSLTH DS    FL1                     DSNAME LENGTH AFTER TRUNCATION
LLTDSN   DS    CL44                    DATA SET NAME
LLTNEXT  EQU   *                       NEXT ENTRY

         YREGS ,                          Equate registers
         PRINT GEN
*
** Convert assembly date from format "YYYYMMDD" to "YYYY-MM-DD"
*
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***
**       Module start
***
***********************************************************************
         SPACE 2
FINDMOD  CSECT ,
FINDMOD  AMODE 31
FINDMOD  RMODE ANY
*
** Standard O/S eyecatcher
*
FM_EC    B    FM_ECL(0,R15)             Bump past EyeCatcher
         DC   AL1(FM_ECE-FM_ECV)        Length of eyecatcher
FM_ECV   DC   C'FINDMOD  &ASMDATE &SYSTIME V&DAVER '
         DC   C'TSO/IPCS command: Find module in storage'
FM_ECE   EQU  *
         DS   0H
FM_ECL   EQU  *-FM_EC
*
** Standard ESA entry housekeeping code
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         LAE   R11,2048(,R12)           Set up for second base reg
         LA    R11,2048(,R11)           Locate 4096 past R12
         USING FINDMOD,R12,R11          Set module base
*
** Obtain Dynamic Save Area
*
         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage
         LR    R13,R1                   Point to Save Area
*
         LR    R14,R13                  To: Address
         L     R15,=AL4(WORKDSL)        To: Length
         SLR   R1,R1                    From: Set length and pad
         MVCL  R14,R0                   Zero out area
*
         MVC   4(4,R13),=C'F1SA'        Indicate stack SA
         USING WORKDS,R13               Get addressibility to area
         EJECT ,
***********************************************************************
***
**  Process the input parm to get the module name and any options
***
***********************************************************************
         SPACE 2
PROCESS_PARAMETER EQU *
         EREG  R1,R1                      Restore R1 on entry
         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?
         BNO   PP$NC                      No, need to look at CBUF
*
** We were called, it has a Batch type (EXEC) parameter
*
         L     R2,0(R1)                   Get address of parm
         SLR   R3,R3                      Clear register
         ICM   R3,B'0011',0(R2)           Get length of parm
         BZ    PP$NULL                    None, leave
         LA    R2,2(R2)                   Bump past parm length HW
         B     PP$PARSE                   Parse the input
*
** We were not called, it is a "Command Processor"
*
PP$NC    DS    0H
         oi    flag1,$f1_tsocp            We are a TSO command processor

         mvc   pm_PBLK(C_PutLineL),C_PutLine Initialize IOPL
         la    r14,pm_IOPL                Locate Our IPOL
         mvc   IOPLUPT-IOPL(4,r14),CPPLUPT-CPPL(r1)
         mvc   IOPLECT-IOPL(4,r14),CPPLECT-CPPL(r1)
         la    r15,pm_ECB                 Locate ECB
         st    r15,IOPLECB-IOPL(r14)      Fill it in

         L     R2,CPPLCBUF-CPPL(R1)       Locate Command Buffer
         SLR   R3,R3                      Clear register
         ICM   R3,B'0011',0(R2)           Get total CBUF length
         SLR   R0,R0                      Clear register
         ICM   R0,B'0011',2(R2)           Get total Command name length
         LA    R15,4                      Length of header
         AR    R2,R15                     Bump past header
         SR    R3,R15                     Decrement for header length
         AR    R2,R0                      Bump past Command length
         SR    R3,R0                      Length of data
*
** Look thru command buffer/parameter for our commands
** Input: R2 - Address of command-buffer/Parameter
**        R3 - Length of command-buffer/Parameter
*
PP$PARSE DS    0H
         LTR   R3,R3                      Check out length
         BZ    PP$NULL                    Length = Zero: Leave
         BM    PP$NULL                    Length < Zero: Leave
         B     PP$SAVE
PP$NULL  DS    0H
         LA    R2,=C'IEFBR14'           Set default module name
         LA    R3,7
PP$SAVE  DS    0H
         STM   R2,R3,PP_PARMS           Save parm addr & length
         EJECT
***********************************************************************
***
**       Startup messages
***
***********************************************************************
         SPACE 2

* Print startup message

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG00L,R15),MSG00
         LA    R15,MSG00L(R15)
         BAS   R14,Print_Message          Print message

* Print the system name from the CVT and O/S info

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG03L,R15),MSG03
         LA    R15,MSG03L+1(R15)
         L     R1,CVTPTR
         MVC   0(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R1)
         LA    R0,L'CVTSNAME
         BAS   R14,LOCATE_FIRST_SPACE
         MVC   0(MSG03BL,R15),MSG03B      Get more text
         LA    R15,MSG03BL+1(R15)
         L     R1,CVTPTR                  Locate CVT
         L     R1,CVTECVT-CVTMAP(R1)      -> ECVT
         MVC   0(L'ECVTPNAM,R15),ECVTPNAM-ECVT(R1)
         LA    R0,L'ECVTPNAM
         BAS   R14,Locate_First_Space
         MVC   1(2,R15),=c'at'
         LA    R15,1+2+1(R15)
         MVC   0(L'ECVTPVER,R15),ECVTPVER-ECVT(R1)
         MVI   L'ECVTPVER(R15),C'.'       Move in dot
         LA    R15,L'ECVTPVER+1(R15)
         MVC   0(L'ECVTPREL,R15),ECVTPREL-ECVT(R1)
         MVI   L'ECVTPREL(R15),C'.'       Move in dot
         LA    R15,L'ECVTPREL+1(R15)
         MVC   0(L'ECVTPMOD,R15),ECVTPMOD-ECVT(R1)
         LA    R15,L'ECVTPMOD(R15)
I$M3X    DS    0H
         BAS   R14,Print_Message          Print Message
*
         BAS   R14,Initialize_Message     Clear output area
         LA    R15,1(R15)
         BAS   R14,Print_Message          Print Message
         EJECT
***********************************************************************
***
**  Validate module name, search, print results and terminate
***
***********************************************************************
         SPACE 2

* Ensure Module name is okay (length and padded with spaces)

         LA    R1,ModuleName              Locate module name area
         CH    R3,=H'8'                   Max length?
         BH    EM$Error                   Over length
         MVI   0(R1),C' '                 Get space
         MVC   1(7,R1),0(R1)              ..Propagate it
         BCTR  R3,0                       Get ready for EX
         EX    R3,EM$SAVEM                Move to our area
         OC    ModuleName(8),=CL8' '      Ensure uppercase

         TRT   ModuleName(8),TableOfGenerics
         BZ    EM$X                       None...
*        OI    Flag1,$F1_Generics
*        B     EM$X
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG98L,R15),MSG98
         LA    R15,MSG98L(R15)
         BAS   R14,Print_Message          Print Message
         MVI   MaxCC,8
         B     Exit

EM$SAVEM MVC   0(*-*,R1),0(R2)            ** Executed **
EM$Error DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG01L,R15),MSG01        Get error txt
         LA    R15,MSG01L(R15)
         BAS   R14,Print_Message          Print message
         MVI   MaxCC,12
         B     Exit
EM$X     DS    0H

* Search the areas for module

         BAS   R14,Search_JPAQ            Search JPAQ
         BAS   R14,Search_ISPLLIB         Search ISPF tasklib
         BAS   R14,Search_Active_LPAQ     Search Active LPA Queue
         BAS   R14,Search_LPA             Search the LPA
         BAS   R14,Search_LNKLST          Search the LNKLST
         BAS   R14,Search_NUCLEUS         Search the Nucleus
         BAS   R14,Search_SVCLIB          Search the SVCLIB !
*
** Free resources and terminate
*
EXIT     DS    0H
         BAS   R14,Initialize_Message     Clear output area
         BAS   R14,Print_Message          Print Message
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG99L,R15),MSG99
         MVC   MSG99N-MSG99(8,R15),ModuleName
         LA    R15,MSG99L+1(R15)
         ICM   R1,B'1111',ModuleCnt       Get count
         BZ    X$NF
         MVC   0(5,R15),=c'found'
         LA    R15,6(R15)
         BAS   R9,EDITFWF
         MVC   1(4,R15),=c'time'
         LA    R15,1+4(R15)
         CLC   ModuleCnt(4),=f'1'
         BE    X$NFX
         mvi   0(R15),c's'
         LA    R15,1(R15)
         B     X$NFX
X$NF     DS    0H
         MVC   0(13,R15),=c'not found :-('
         LA    R15,13(R15)
X$NFX    DS    0H
         BAS   R14,Print_Message          Print Message
*-Free Storage whilst retaining return code
         LR    R2,R13                     Get storage address
         SLR   R3,R3
         IC    R3,MAXCC
         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage
         LR    R15,R3                     Set return code
*-Return to caller
         PR    ,                          Return to caller
         EJECT
***********************************************************************
***
** Search the SVCLIB
***
***********************************************************************
         SPACE 2
Search_SVCLIB DS 0H
         ST    R14,SR_RA                  Save return code

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05SVC,R15),MSG05SVC
         LA    R15,L'MSG05SVC(R15)
         BAS   R14,Print_Message          Print message

         L     R4,CVTPTR                  -> CVT
         L     R4,CVTSVDCB-CVTMAP(R4)     Locate SVCLIB DCB
         LA    R1,ModuleName              Locate module name
         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module
         LTR   R15,R15                    Found?
         BNZ   SSVC$NF

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L(R15)
         BAS   R14,Print_Message          Print message
         BAS   R14,Initialize_Message     Clear output area
         LA    R15,2(R15)
         BAS   R14,Append_Module_Attributes
         BAS   R14,Print_Message          Print message
         B     SSVC$X

SSVC$NF  DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
*
** Common exit from Search_SVCLIB
*
SSVC$X   DS    0H
         L     R14,SR_RA                  Get return address
         BSM   0,R14                      Continue
         EJECT
***********************************************************************
***
** Search the ISPF Task lib
***
***********************************************************************
         SPACE 2
Search_ISPLLIB DS 0H
         ST    R14,SR_RA                  Save return code

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05ITL,R15),MSG05ITL
         LA    R15,L'MSG05ITL(R15)
         BAS   R14,Print_Message          Print message

         DEVTYPE =CL8'ISPLLIB',DOUBLE     allocated?
         LTR   R15,R15
         BNZ   SITL$NA                    No, leave

         LA    R4,W_TSKDCB             Locate tasklib DCB
         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R4),=CL8'ISPLLIB'
         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list
         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib
         LTR   R15,R15                 Test open...
         BNZ   SITL$NF                 Oops, leave

         LA    R1,ModuleName              Locate module name
         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module
         LR    R5,R15                     Save rc

         MVC   PARMLIST(C_CLOSEL),C_CLOSE
         CLOSE ((4)),MF=(E,PARMLIST)   Close the file
         FREEPOOL (4)

         LTR   R5,R5                      Module in //ISPLLIB?
         BNZ   SITL$NF                    No...

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L+1(R15)
         LA    R1,=CL8'ISPLLIB'           Set DDNAME
         BAS   R14,Append_Concatenation
         BAS   R14,Print_Message          Print message
         BAS   R14,Initialize_Message     Clear output area
         LA    R15,2(R15)
         BAS   R14,Append_Module_Attributes
         BAS   R14,Print_Message          Print message
         B     SITL$X

SITL$NF  DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
         B     SITL$X
*
** //ISPLLIB not allocated
*
SITL$NA  DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG02L,R15),MSG02
         LA    R15,MSG02L(R15)
         BAS   R14,Print_Message          Print message
*
** Common exit from Search_ISPLLIB
*
SITL$X   DS    0H
         L     R14,SR_RA                  Get return address
         BSM   0,R14                      Continue
         EJECT
***********************************************************************
***
** Search the active LPA queue
***
***********************************************************************
         SPACE 2
Search_Active_LPAQ DS 0h
         ST    R14,SR_RA                  Save return code

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05ALQ,R15),MSG05ALQ
         LA    R15,L'MSG05ALQ(R15)
         BAS   R14,Print_Message          Print message

* Start at the first LPA queue entry we can

         L     R1,CVTPTR                  -> CVT
         TM    CVTOSLV2-CVTMAP(R1),CVTDYLPA Dynamic LPA available?
         BNO   SAL$MO                     Nope, Start elsewhere
         L     R14,CVTECVT-CVTMAP(R1)      -> ECVT
         ICM   R3,B'1111',ECVTDLPF-ECVT(R14) Any queue to check?
         BNZ   SAL$MX
SAL$MO   DS    0H
         L     R1,CVTQLPAQ-CVTMAP(R1)
SAL$MX   DS    0H

* Process the CDEs

SAL$L    DS    0H
         CLC   CDNAME-CDENTRY(8,R3),ModuleName
         BNE   SAL$LB

         OI    Flag1,$F1_Found            We found at least one

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L+1(R15)
         MVC   0(4,R15),=C'EPA='
         LA    R15,4(R15)
         UNPK  0(9,r15),CDENTPT-CDENTRY(5,R3)
         mvz   0(8,r15),=8x'00'
         tr    0(8,r15),=c'0123456789ABCDEF'
*        mvi   8(r15),c' '
         LA    R15,8(R15)
         BAS   R14,Print_Message          Print message

SAL$LB   DS    0H
         ICM   R3,B'1111',CDCHAIN-CDENTRY(R3)
         BNZ   SAL$L
         TM    Flag1,$F1_Found            We found at least one
         BO    SAL$X
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
*
** Common exit from Search_Active_LPAQ
*
SAL$X    DS    0H
         NI    Flag1,255-$F1_Found        Ensure good for next routine
         L     R14,SR_RA                  Get return address
         BSM   0,R14                      Continue
         EJECT
***********************************************************************
***
** Search the JPAQ
***
***********************************************************************
         SPACE 2
Search_JPAQ DS  0H
         ST    R14,SR_RA                  Save return code
*
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05JPAQ,R15),MSG05JPAQ
         LA    R15,L'MSG05LPA(R15)
         BAS   R14,Print_Message          Print message

         CSVQUERY INEPNAME=ModuleName,    Search for module            @
               SEARCH=JPA,                ..in the LPA only            @
               OUTVALID=LPA_VALID,        ..valid information          @
               OUTEPA=LPA_EPA,            ..address of module          @
               OUTLENGTH=LPA_LENGTH,      ..length of module           @
               OUTMJNM=LPA_MJNM,                                       @
               MF=(E,PARMLIST)
         LTR   R15,R15
         BNZ   SJPAQ$NF

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L+1(R15)
         MVC   0(4,R15),=C'EPA='
         LA    R15,4(R15)
         UNPK  0(9,r15),LPA_EPA(5)
         mvz   0(8,r15),=8x'00'
         tr    0(8,r15),=c'0123456789ABCDEF'
         MVC   8(2,R15),=c' ('
         LA    R15,10(r15)
         LA    R1,LPA_EPA
         BAS   R14,Retrieve_VSLOC
         AR    R15,R0                     Bump past description
         MVI   0(R15),C')'
         LA    R15,1(R15)
         BAS   R14,Print_Message          Print message
         B     SJPAQ$X

SJPAQ$NF DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
         B     SLPA$X
*
** Common exit from Search_JPAQ
*
SJPAQ$X  DS    0H
         L     R14,SR_RA
         BSM   0,R14
         EJECT
***********************************************************************
***
** Search the LPA
***
***********************************************************************
         SPACE 2
Search_LPA DS 0H
         ST    R14,SR_RA                  Save return code
*
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05LPA,R15),MSG05LPA
         LA    R15,L'MSG05LPA(R15)
         BAS   R14,Print_Message          Print message

         CSVQUERY INEPNAME=ModuleName,    Search for module            @
               SEARCH=LPA,                ..in the LPA only            @
               OUTVALID=LPA_VALID,        ..valid information          @
               OUTEPA=LPA_EPA,            ..address of module          @
               OUTLENGTH=LPA_LENGTH,      ..length of module           @
               OUTMJNM=LPA_MJNM,                                       @
               MF=(E,PARMLIST)
         LTR   R15,R15
         BNZ   SLPA$NF

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L+1(R15)
         MVC   0(4,R15),=C'EPA='
         LA    R15,4(R15)
         UNPK  0(9,r15),LPA_EPA(5)
         mvz   0(8,r15),=8x'00'
         tr    0(8,r15),=c'0123456789ABCDEF'
         MVC   8(2,R15),=c' ('
         LA    R15,10(r15)
         LA    R1,LPA_EPA
         BAS   R14,Retrieve_VSLOC
         AR    R15,R0                     Bump past description
         MVI   0(R15),C')'
         LA    R15,1(R15)
         BAS   R14,Print_Message          Print message
         B     SLPA$X

SLPA$NF  DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
         B     SLPA$X
*
** Common exit from Search_LPA
*
SLPA$X   DS    0H
         L     R14,SR_RA
         BSM   0,R14
         EJECT
***********************************************************************
***
** Search the LNKLST
***
***********************************************************************
         SPACE 2

Search_LNKLST DS 0H
         ST    R14,SR_RA                  Save return code

         L     R1,CVTPTR
         TM    CVTOSLV1-CVTMAP(R1),CVTH6603 Have Dynamic LNKLST?
         bo    SLNK$D
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05LNKI,R15),MSG05LNKI
         LA    R15,L'MSG05LNKI(R15)
         BAS   R14,Print_Message          Print message

         L     R3,CVTPTR
         L     R3,CVTLLTA-CVTMAP(R3)
         L     R7,LLTCOUNT-LLT(R3)
         LA    R3,LLTENTRY-LLT(R3)
SLNK$OL  DS    0H
         LA    R2,LLTDSN-LLTENTRY(R3)
         SLR   R9,R9                      No VOLUME
         BAS   R14,Dynamic_Allocation
         LTR   R15,R15
         BZ    SLNK$OLO
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG07L,R15),MSG07
         LA    R15,MSG07L(R15)
         MVC   0(L'LLTDSN,R15),LLTDSN-LLTENTRY(R3)
         LA    R15,L'LLTDSN(R15)
         BAS   R14,Print_Message          Print message
         B     SLNK$OLB
SLNK$OLO DS    0H
         LA    R4,W_TSKDCB             Locate tasklib DCB
         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R4),0(R1)   Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list
         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib
         LTR   R15,R15                 Test open...
         BNZ   SLNK$OLB                Oops, leave

         LA    R1,ModuleName              Locate module name
         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module
         LR    R5,R15                     Save rc

         MVC   PARMLIST(C_CLOSEL),C_CLOSE
         CLOSE ((4)),MF=(E,PARMLIST)   Close the file
         FREEPOOL (4)

         LTR   R5,R5                      Module in this library?
         BNZ   SLNK$OLB                   No...

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L(R15)
         MVC   1(7,R15),=c'in DSN='
         LA    R15,8(R15)
         MVC   0(L'LLTDSN,R15),LLTDSN-LLTENTRY(R3)
         LA    R0,L'LLTDSN
         BAS   R14,Locate_First_Space
         BAS   R14,Print_Message          Print message
         BAS   R14,Initialize_Message     Clear output area
         LA    R15,2(R15)
         BAS   R14,Append_Module_Attributes
         BAS   R14,Print_Message          Print message
SLNK$OLB DS    0H
         LA    R3,LLTNEXT-LLTENTRY(R3)
         BCT   R7,SLNK$OL
         B     SLNK$X

* Dynamic LNKLSTs

SLNK$D   DS    0H
#SLNK$LEN EQU  64*1024
         L     R0,=A(#SLNK$LEN)
         GETMAIN R,LV=(0)
         STM   R0,R1,SLNK_Area
         LR    R8,R1
         USING DLAAHDR,R8
         CSVDYNL REQUEST=LIST,                                         X
               ANSAREA=DLAAHDR,                                        X
               ANSLEN==A(#SLNK$LEN),                                   X
               USERINFO=YES,                                           X
               MF=(E,CSVDYNL)
         ICM   R15,B'1111',DLAAH#REM
         BNZ   SLNK$DX                   Hmmm, errors?
         L     R7,DLAAHFIRSTLSADDR     Address of first DLAALS
SLNK$DSL DS    0H

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05LNKS,R15),MSG05LNKS
         LA    R15,L'MSG05LNKS(R15)
         MVC   0(L'DLAALSNAME,R15),DLAALSNAME-DLAALS(R7)
         LA    R0,L'DLAALSNAME
         BAS   R14,Locate_First_Space
         TM    DLAALSFLAGS-DLAALS(R7),DLAALSCURRENT
         BNO   SLNK$DSCX
         MVC   0(8,R15),=c',Current'
         LA    R15,8(R15)
SLNK$DSCX DS   0H
         MVI   0(R15),C')'
         LA    R15,2(R15)
         BAS   R14,Print_Message          Print message

         L     R3,DLAALSFIRSTDSADDR-DLAALS(R7)
SLNK$DDL DS    0H
         LA    R2,DLAADSNAME-DLAADS(R3)
         LA    R9,DLAADSVOLID-DLAADS(R3)
         BAS   R14,Dynamic_Allocation
         LTR   R15,R15
         BZ    SLNK$DDLO
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG07L,R15),MSG07
         LA    R15,MSG07L(R15)
         MVC   0(L'DLAADSNAME,R15),DLAADSNAME-DLAADS(R3)
         LA    R0,L'DLAADSNAME
         BAS   R14,Locate_First_Space
         MVC   1(9,R15),=c'on volume'
         LA    R15,1+9+1(R15)
         MVC   0(L'DLAADSVOLID,R15),DLAADSVOLID-DLAADS(R3)
         LA    R15,L'DLAADSVOLID(R15)
         BAS   R14,Print_Message          Print message
         B     SLNK$DDLB
SLNK$DDLO DS   0H
         LA    R4,W_TSKDCB             Locate tasklib DCB
         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R4),0(R1)   Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list
         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib
         LTR   R15,R15                 Test open...
         BNZ   SLNK$DDLB               Oops, leave

         LA    R1,ModuleName              Locate module name
         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module
         LR    R5,R15                     Save rc

         MVC   PARMLIST(C_CLOSEL),C_CLOSE
         CLOSE ((4)),MF=(E,PARMLIST)   Close the file
         FREEPOOL (4)

         LTR   R5,R5                      Module in this library?
         BNZ   SLNK$DDLB                  No...

         OI    Flag1,$F1_Found

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L(R15)
         MVC   1(7,R15),=c'in DSN='
         LA    R15,8(R15)
         MVC   0(L'DLAADSNAME,R15),DLAADSNAME-DLAADS(R3)
         LA    R0,L'DLAADSNAME
         BAS   R14,Locate_First_Space
         MVC   1(9,R15),=c'on volume'
         LA    R15,1+9+1(R15)
         MVC   0(L'DLAADSVOLID,R15),DLAADSVOLID-DLAADS(R3)
         LA    R15,L'DLAADSVOLID(R15)
         BAS   R14,Print_Message          Print message
         BAS   R14,Initialize_Message     Clear output area
         LA    R15,2(R15)
         BAS   R14,Append_Module_Attributes
         BAS   R14,Print_Message          Print message

SLNK$DDLB DS   0H
         ICM   R3,B'1111',DLAADSNEXTADDR-DLAADS(R3) Next Library
         BNZ   SLNK$DDL

SLNK$DSLB DS   0H
         ICM   R7,B'1111',DLAALSNEXTADDR-DLAALS(R7) Next LNKLST set
         BNZ   SLNK$DSL
         LM    R0,R1,SLNK_Area
         FREEMAIN R,LV=(0),A=(1)
         DROP  R8
SLNK$DX  DS    0H

         TM    Flag1,$F1_Found            In any LNKLST?
         BO    SLNK$X
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
         B     SLNK$X
*
** Common exit from Search_LNKLST
*
SLNK$X   DS    0H
         NI    Flag1,255-$F1_Found        Ensure good for next routine
         L     R14,SR_RA
         BSM   0,R14
         EJECT
***********************************************************************
***
** Search the Nucleus
***
***********************************************************************
         SPACE 2
Search_Nucleus DS 0H
         ST    R14,SR_RA                  Save return code
*
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG05L,R15),MSG05
         LA    R15,MSG05L+1(R15)
         MVC   0(L'MSG05NUC,R15),MSG05NUC
         LA    R15,L'MSG05NUC(R15)
         BAS   R14,Print_Message          Print message

         NUCLKUP  BYNAME,                 Locate Nucleus module        @
               NAME=ModuleName,           ..Name to search for         @
               ADDR=LPA_EPA               ..Return Address here
         LTR   R15,R15
         BNZ   SNUC$NF

         L     R1,ModuleCnt
         LA    R1,1(R1)
         ST    R1,ModuleCnt

         BAS   R14,Initialize_Message     Clear output area
         MVC   0(MSG06L,R15),MSG06
         MVC   MSG06N-MSG06(8,R15),ModuleName
         LA    R15,MSG06L+1(R15)
         MVC   0(4,R15),=C'EPA='
         LA    R15,4(R15)
         UNPK  0(9,r15),LPA_EPA(5)
         mvz   0(8,r15),=8x'00'
         tr    0(8,r15),=c'0123456789ABCDEF'
         MVC   8(2,R15),=c' ('
         LA    R15,10(r15)
         LA    R1,LPA_EPA
         BAS   R14,Retrieve_VSLOC
         AR    R15,R0                     Bump past description
         MVI   0(R15),C')'
         LA    R15,1(R15)
         BAS   R14,Print_Message          Print message
         B     SNUC$X

SNUC$NF  DS    0H
         BAS   R14,Initialize_Message     Clear output area
         MVC   0(L'MSG05NF,R15),MSG05NF
         LA    R15,L'MSG05NF(R15)
         BAS   R14,Print_Message          Print message
         B     SNUC$X
*
** Common exit from Search_Nucleus
*
SNUC$X   DS    0H
         L     R14,SR_RA
         BSM   0,R14
         EJECT
***********************************************************************
***
** Dynamically allocate file
**
** Input: R2 has DSNAME
**        R9 has volume or zero for none
**
** Output: R1 has pointer to DDNAME
***
***********************************************************************
         SPACE 2

Dynamic_Allocation ds 0h
         ST    R14,DA_RA                  Get return address
* Format Request block

         LA    R4,PARMLIST                Get address of work area
         ST    R4,DOUBLE                  Save address
         OI    DOUBLE,S99RBPND            Indicate last one
         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area
         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK
         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers
         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs
         LA    R6,24(R5)    6*4=24        Bump past Text pointers

** The address of each of the text Units will be stored in the
** request block text PTR area as they are being defined,
** Active registers are: R5 - Address in text unit pointers
**                       R6 - Address in text unit define area

         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE
***-------------------------------------- DDNAME=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALRTDDN                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME
         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME
*
         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit
***-------------------------------------- DISP=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALSTATS                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,1                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR
*
         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit
***-------------------------------------- Free=Close
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALCLOSE                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,0                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,0                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
*
         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit
***-------------------------------------- UNIT=SYSALLDA
         LTR   R9,R9
         BZ    DA$VOLX
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALUNIT                  Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(8,R6),=CL8'SYSALLDA'
*
         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit
***-------------------------------------- VOL=SER=xxxxx
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALVLSER                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,6                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(6,R6),0(R9)
*
         LA    R6,S99TUPAR-S99TUNIT+6(R6)   Bump past this Text Unit
DA$VOLX  DS    0H
***-Last--------------------------------- DSN=
         ST    R6,0(R5)                     Save Address of Text Unit
         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication
*
         LA    R14,DALDSNAM                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,44                       Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(44,R6),0(R2)
***-------------------------------------- Complete and make request

* Perform dynamic allocation

         LA    R1,DOUBLE                  Get address of Request BLK
         DYNALLOC ,                       Invoke SVC 99
         L     R1,DOUBLE2                 Locate the DDNAME
         L     R14,DA_RA                  Get return address
         BSM   0,R14                      Return to caller
         EJECT
***********************************************************************
***
**       Misc internal subroutines
***
***********************************************************************
         SPACE 2

* Append load module attributes from the BLDL area into the print line

Append_Concatenation DS 0H
         ST    R14,AC_RA
         ST    R15,AC_SREG

         L     R14,PSATOLD-PSA            -> TCB
         L     R14,TCBTIO-TCB(,R14)       -> TIOT
         LA    R14,TIOENTRY-TIOT1(R14)    Locate first DD entry
AC$L     DS    0H
         SLR   R0,R0                      Set register to zero
         ICM   R0,B'0001',TIOELNGH-TIOENTRY(R14) Get length of entry
         BZ    AC$X                       None, end of the TIOT
         CLC   TIOEDDNM-TIOENTRY(8,R14),0(R1) Found it?
         BE    AC$F                       Yes, continue
         AR    R14,R0                     Bump to next DD entry
         B     AC$L
AC$F     DS    0H
         LA    R2,BLDLA_ENTRY
         LA    R1,0
AC$CL    DS    0H
         CLM   R1,B'0001',PDS2CNCT-PDS2(R2)
         BE    AC$CLX
         SLR   R0,R0                      Set register to zero
         ICM   R0,B'0001',TIOELNGH-TIOENTRY(R14) Get length of entry
         BZ    AC$X                       None, end of the TIOT
         LA    R1,1(R1)                   Increase concat number
         AR    R14,R0
         B     AC$CL
AC$CLX   DS    0H
         LA    R1,AC_SWAEPAX             Locate start of EPA
         ST    R1,DOUBLE                  Save address
         XC    0(L'SWAEPAX,R1),0(R1)      Initialize to binary zeros
         MVC   SWVA-ZB505(3,R1),TIOEJFCB-TIOENTRY(R14) JFCB token
         MVI   SWBLKID-ZB505(R1),SWJFCBID Indicate we need JFCB
         MVC   PARMLIST(C_SWAREQL),C_SWAREQ Initialize Parameter List
         SWAREQ EPA=DOUBLE,UNAUTH=YES,MF=(E,PARMLIST) Get control block
         LTR   R15,R15                    Successful?
         BNZ   AC$X                       No, leave
         LA    R1,AC_SWAEPAX             Locate start of EPA
         ICM   R1,B'1111',SWBLKPTR-ZB505(R1) locate JFCB
         BZ    AC$X
         L     R15,AC_SREG
         MVC   1(7,R15),=C'in DSN='
         LA    R15,8(R15)
         MVC   0(L'JFCBDSNM,R15),JFCBDSNM-INFMJFCB(R1)
         LA    r0,L'JFCBDSNM
         BAS   R14,Locate_First_Space
         L     R14,AC_RA
         BSM   0,R14
AC$X     DS    0H
         L     R15,AC_SREG
         L     R14,AC_RA
         BSM   0,R14

* Append load module attributes from the BLDL area into the print line

Append_Module_Attributes ds 0h
         ST    R14,AMA_RA
         LA    R2,BLDLA_ENTRY
         MVC   1(5,R15),=c'Size='
         LA    R15,6(R15)
         UNPK  0(7,R15),PDS2STOR-PDS2(4,R2)
         MVZ   0(6,R15),=8x'00'
         TR    0(6,R15),=C'0123456789ABCDEF'
         MVI   6(R15),C' '
         LA    R15,7(R15)

* Need to check macro level and test for 64 bitness here!
         MVC   0(5,R15),=c'Rmode'
         LA    R15,5(R15)
         TM    PDS2FTB2-PDS2(R2),PDSLRMOD
         BO    AMA$RAny
         MVC   0(2,R15),=C'24'
         LA    R15,3(R15)
         B     AMA$Rx
AMA$RAny DS    0H
         MVC   0(3,R15),=C'Any'
         LA    R15,4(R15)
AMA$RX   DS    0H
*
         MVC   0(5,R15),=c'Amode'
         LA    R15,5(R15)
         TM    PDS2FTB2-PDS2(R2),PDSMAMOD  Both on?
         BO    AMA$AANY                   Yes, its ANY
         TM    PDS2FTB2-PDS2(R2),BIT6     Just one?
         BO    AMA$A31                    Yes, its 31
         MVC   0(2,R15),=C'24'
         LA    R15,3(R15)
         B     AMA$AX
AMA$A31  DS    0H
         MVC   0(2,R15),=C'31'
         LA    R15,3(R15)
         B     AMA$AX
AMA$AANY DS    0H
         MVC   0(3,R15),=C'Any'
         LA    R15,4(R15)
AMA$AX   DS    0H

         TM    PDS2ATR1-PDS2(R2),PDS2RENT
         BNO   AMA$RENTX
         MVC   0(9,R15),=C'Reentrant'
         LA    R15,10(R15)
AMA$RENTX DS   0H
         TM    PDS2ATR1-PDS2(R2),PDS2REUS
         BNO   AMA$REUSX
         MVC   0(8,R15),=C'Reusable'
         LA    R15,9(R15)
AMA$REUSX DS   0H

         L     R14,AMA_RA
         BSM   0,R14

*
** Determine V/S location of input 31-bit memory (below the Bar)
**
** R1 has the address of a fullword with the address (binary) to lookup
** R15 has the output location of the V/S area
*

Retrieve_VSLOC ds 0h
 stm   r2,r4,RV_REGS

 mvc   DOUBLE2(4),0(R1)                 Get input fullword
 ni    DOUBLE2,255-X'80'                Ensure high order is off
 la    r1,double2

 L     R2,CVTPTR                          -> CVT
 L     R3,CVTGDA-CVTMAP(R2)               -> GDA
 L     R2,CVTSMEXT-CVTMAP(R2)             -> CVT Virtual Storage Ext.

 clc   0(4,R1),=X'7FFFFFFF'               Upper limit?
 bnl   rv$invalid
 clc   0(4,R1),GDAEPVT-GDA(R3)            In Ext Private?
 bnl   RV$XPVT
 clc   0(4,R1),GDAECSA-GDA(R3)            In Ext CSA?
 bnl   RV$XCSA
 icm   R0,B'1111',CVTEMLPS-CVTVSTGX(R2)   Get starting addr of xmlpa
 BZ    RV$CXMLPAX                         Zero: Area not being used
 clc   0(4,R1),CVTEMLPS-CVTVSTGX(R2)      In Ext-MLPA?
 bnl   RV$XMLPA
RV$CXMLPAX ds 0h
 icm   R0,B'1111',CVTEFLPS-CVTVSTGX(R2)   Get starting addr of xflpa
 BZ    RV$CXFLPAX                         Zero: Area not being used
 clc   0(4,R1),CVTEFLPS-CVTVSTGX(R2)      In Ext-FLPA?
 bnl   RV$XFLPA
RV$CXFLPAX ds 0h
 clc   0(4,R1),CVTEPLPS-CVTVSTGX(R2)      In Ext-PLPA?
 bnl   RV$XPLPA
 clc   0(4,R1),GDAESQA-GDA(R3)            In Ext SQA?
 bnl   RV$XSQA
 clc   0(4,R1),CVTERWNS-CVTVSTGX(R2)      In Ext-R/W Nuc?
 bnl   RV$XRWNUC
 clc   0(4,R1),=X'01000000'               In Ext-R/O Nuc?
 bnl   RV$XRONUC
 clc   0(4,R1),CVTRONS-CVTVSTGX(R2)       In R/O Nuc?
 bnl   RV$RONUC
 clc   0(4,R1),CVTRWNS-CVTVSTGX(R2)       In R/W Nuc?
 bnl   RV$RWNUC
 clc   0(4,R1),GDASQA-GDA(R3)             In SQA?
 bnl   RV$SQA
 clc   0(4,R1),CVTPLPAS-CVTVSTGX(R2)      In PLPA?
 bnl   RV$PLPA
 ICM   R0,B'1111',CVTFLPAS-CVTVSTGX(R2)   Get starting address
 BZ    RV$CFLPAX                          Zero: Area not used
 clc   0(4,R1),CVTFLPAS-CVTVSTGX(R2)      In FLPA?
 bnl   RV$FLPA
RV$CFLPAX ds 0h
 ICM   R0,B'1111',CVTMLPAS-CVTVSTGX(R2)   Get starting address
 BZ    RV$CMLPAX                          Zero: Area not used
 clc   0(4,R1),CVTMLPAS-CVTVSTGX(R2)      In MLPA?
 bnl   RV$MLPA
RV$CMLPAX ds 0h

 clc   0(4,R1),GDACSA-GDA(R3)             In CSA?
 bnl   RV$CSA
 L     R4,PSAAOLD-PSA                     -> PSA
 L     R4,ASCBLDA-ASCB(,R4)               -> LDA
 clc   0(4,R1),LDASTRTA-LDA(R4)           In private region?
 bnl   RV$PVT
 MVC   0(10,R15),=C'PSA+System'
 LA    R0,10
 B     RV$X
RV$invalid ds 0h
 MVC   0(3,R15),=c'n/a'
 LA    R0,3
 B     RV$X
RV$XPVT ds 0h
 MVC   0(11,R15),=c'Ext-Private'
 LA    R0,11
 B     RV$X
RV$XCSA ds 0h
 MVC   0(7,R15),=c'Ext-CSA'
 LA    R0,7
 B     RV$X
RV$XFLPA ds 0h
 MVC   0(8,R15),=c'Ext-FLPA'
 LA    R0,8
 B     RV$X
RV$XMLPA ds 0h
 MVC   0(8,R15),=c'Ext-MLPA'
 LA    R0,8
 B     RV$X
RV$XPLPA ds 0h
 MVC   0(8,R15),=c'Ext-PLPA'
 LA    R0,8
 B     RV$X
RV$XSQA  ds 0h
 MVC   0(7,R15),=c'Ext-SQA'
 LA    R0,7
 B     RV$X
RV$XRWNUC ds 0h
 MVC   0(15,R15),=c'Ext-R/W Nucleus'
 LA    R0,15
 B     RV$X
RV$XRONUC ds 0h
 MVC   0(15,R15),=c'Ext-R/O Nucleus'
 LA    R0,15
 B     RV$X
RV$RONUC ds 0h
 MVC   0(11,R15),=c'R/O Nucleus'
 LA    R0,11
 B     RV$X
RV$RWNUC ds 0h
 MVC   0(11,R15),=c'R/W Nucleus'
 LA    R0,11
 B     RV$X
RV$SQA ds 0h
 MVC   0(3,R15),=c'SQA'
 LA    R0,3
 B     RV$X
RV$PLPA ds 0h
 MVC   0(4,R15),=c'PLPA'
 LA    R0,4
 B     RV$X
RV$FLPA ds 0h
 MVC   0(4,R15),=c'FLPA'
 LA    R0,4
 B     RV$X
RV$MLPA ds 0h
 MVC   0(4,R15),=c'MLPA'
 LA    R0,4
 B     RV$X
RV$CSA ds 0h
 MVC   0(3,R15),=c'CSA'
 LA    R0,3
 B     RV$X
RV$PVT ds 0h
 MVC   0(7,R15),=c'Private'
 LA    R0,7
 B     RV$X
RV$X ds 0h
 lm    r2,r4,RV_REGS
 BSM   0,R14
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for 0
         BZ    EDITFWF0                   Yes, put zero
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),EDITFWFP
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R9                       Return to caller
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '                Blank?
         BE    LFS$X                      Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat
LFS$X    EQU   *
         BSM   0,R14                      Return to caller
*
** Issue BLDL (with DCB)
**
** Input: R1 has address of 8 byte module to look for
**        R4 has address of the DCB
** Output: R15 has return code from BLDL
*
ISSUE_BLDL_WDCB DS  0H
         ST    R14,DOUBLE                 Save return address
         XC    BLDLA(BLDLAL),BLDLA        Clear to zeros
         MVC   BLDLA_FF(2),=AL2(1)        Set number of members
         MVC   BLDLA_LL(2),=AL2(BLDLA_ENTRYL) Move in entry length
         MVC   BLDLA_ENTRY+(PDS2NAME-PDS2)(8),0(R1)
         BLDL  (4),BLDLA                  Perform BLDL
         L     R14,DOUBLE
         BSM   0,R14
*
** Subroutine: Clear Message to blanks
*
Initialize_Message EQU *
         MVI   Message,C' '               Get space
         MVC   Message+1(L'Message-1),Message ..Propagate it
         LA    R15,Message                Point to blank msg area
         BSM   0,R14                      Return to caller
*
** Subroutine: Print message to IPCS or to TSO screen
*
Print_Message EQU *
         ST    R14,PM_RA                  Save Return address
         TM    Flag1,$F1_TSOCP            TSO command processor?
         BNO   PM$TPUT
         la    r1,MessageH                Locate start
         sr    r15,r1                     Length = end - start
         sth   R15,MessageH               Save length
         PUTLINE PARM=pm_PBLK,                                         @
               OUTPUT=(MessageH,TERM,SINGLE,DATA),                     @
               MF=(E,pm_IOPL)
         l     r14,pm_ra
         bsm   0,r14                      Return to caller
PM$TPUT  DS    0H
         TPUT  Message,79
         L     R14,PM_RA
         BSM   0,R14
         EJECT
***********************************************************************
***
** Constants
***
***********************************************************************
         SPACE 2
         LTORG ,
*
** Messages
*
MSG00    DC    C'FINDMOD  - version &DAVER - '
         DC    C'TSO module search command'
MSG00L   EQU   *-MSG00
MSG01    DC    C'Module name too long.  Must be 1-8 characters'
MSG01L   EQU   *-MSG01
MSG02    DC    C'..ISPLLIB not allocated'
MSG02L   EQU   *-MSG02
MSG03    DC    C'The system name is'
MSG03L   EQU   *-MSG03
MSG03B   DC    C'. Operating system is'
MSG03BL  EQU   *-MSG03B
MSG05    DC    C'Searching: '
MSG05L   EQU   *-MSG05
MSG05NF  DC    C'..Not found'
MSG05JPAQ DC   C'JPAQ'
MSG05ITL DC    C'ISPLLIB (ISPF Task library)'
MSG05ALQ DC    C'Active LPA Queue'
MSG05LNKI DC    C'LNKLST (IPL)'
MSG05LNKS DC    C'LNKLST Set ('
MSG05SVC DC    C'SVCLIB'
MSG05LPA DC    C'LPA'
MSG05NUC DC    C'Nucleus'
MSG06    DC    C'>> Module '
MSG06N   DC    CL8'********'
         DC    C' found'
MSG06L   EQU   *-MSG06
MSG07    DC    C'.. Could not allocate DSN='
MSG07L   EQU   *-MSG07
MSG98    DC    C'Sorry but Generics are not supported yet'
MSG98L   EQU   *-MSG98
MSG99    DC    C'Module '
MSG99N   DC    C'xxxxxxxx'
         DC    C' was'
MSG99L   EQU   *-MSG99
*
C_Putline PUTLINE MF=L
C_Putlinel equ *-C_PutLine
C_LSTI    OPEN  (*-*,(INPUT)),MF=L
C_LSTIL   EQU   *-C_LSTI
C_TSKDCB  DCB   DSORG=PO,MACRF=R,DDNAME=CTASKDCB
C_TSKDCBL EQU   *-C_TSKDCB
C_CLOSE   CLOSE (*-*),MF=L
C_CLOSEL  EQU   *-C_CLOSE
C_SWAREQ  SWAREQ FCODE=RL,EPA=*-*,MF=L
C_SWAREQL EQU *-C_SWAREQ

TableOfGenerics DC 256X'00'
         ORG   TableOfGenerics+C'*'
         DC    C'*'
         ORG   TableOfGenerics+C'%'
         DC    C'%'
         ORG   ,
         DS    0D
FINDMOD_length EQU *-FINDMOD
         EJECT
***********************************************************************
***
**  Dynamic Save Area
***
***********************************************************************

WORKDS       DSECT ,
             DS    18F                Register Save Area
DOUBLE       DS    D                  Double word work area
DOUBLE2      DS    2D                 Double word work area
PARMLIST     DS    256X               Parameter list for calls
SR_RA        DS    F                  Search Routine Return addr
PP_PARMS     DS    2F                 Parse parms
ModuleName   DS    CL8                Module Name
ModuleCNT    DS    F                  Module Count
DA_RA        ds    F                  Return Address
AMA_RA       ds    F                  Return Address
AC_SWAEPAX   DS    XL(L'SWAEPAX)      SWAEPAX area
AC_RA        DS    F                  Return Address
AC_SREG      DS    F                  Save register for routine
SLNK_Area    DS    2F                 Getmained area
RV_REGS      DS    3F                 Regs saved for Retrieve_VSLOC
             ds    0f                 Print_Message routine:
PM_RA        ds    F                  ..Return Address
pm_IOPL      ds    xl(#IOPL)          ..Input/Output Parm List
pm_PBLK      ds    xl(C_PutLineL)     ..PUTLINE block
pm_ECB       ds    f                  ..Input/Output Parm List
MessageH     ds    xl4                Header for PUTLINE
Message      ds    CL133              Message area

LPA_MJNM     DS    CL8
LPA_EPA      DS    F
LPA_VALID    DS    F
LPA_LENGTH   DS    F
LPA_MINOR    DS    X
*
BLDLA        DS    0F                 BLDL area
BLDLA_FF     DS    X'00,00'           ..Total number of entries
BLDLA_LL     DS    X'00,00'           ..Length of the area
BLDLA_ENTRY  DS    XL(PDS2USRD-PDS2)  ..Start of user data
BLDLA_USERD  DS    CL62               ..User data (enough for ISPF)
BLDLA_ENTRYL EQU   *-BLDLA_ENTRY      ..Length of PDS entry
BLDLAL       EQU   *-BLDLA            ..Length of PDS area
             DS    0D
W_TSKDCB     DS    XL(C_TSKDCBL)      Task DCB
             CSVDYNL MF=(L,CSVDYNL)
*
FLAG1        DS    B'00000000'        Flag 1
$F1_Found    EQU   B'10000000'        ..Found one in this area?
$F1_TSOCP    EQU   B'01000000'        ..TSO command processor?
$F1_Generics EQU   B'00100000'        ..Generic char in modname?
MAXCC        DS    X                  Maximum condition code
             DS    0D                 End of DSECT
WORKDSL      EQU   *-WORKDS
             END   ,
